---
# --- Python Setup ---
- name: Ensure Python 3 and venv are installed
  ansible.builtin.package:
    name:
      - python3
      - python3-venv
    state: present
  become: true
  when: inventory_hostname in groups['proxmox_servers'] | default([])

- name: Create a Python virtual environment
  ansible.builtin.command:
    cmd: python3 -m venv /opt/ansible_venv
    creates: /opt/ansible_venv
  become: true
  when: inventory_hostname in groups['proxmox_servers'] | default([])

- name: Install Proxmox dependencies in venv
  ansible.builtin.pip:
    name:
      - proxmoxer
      - requests
    virtualenv: /opt/ansible_venv
  become: true
  when: inventory_hostname in groups['proxmox_servers'] | default([])

- name: Set the Python interpreter
  ansible.builtin.set_fact:
    ansible_python_interpreter: /opt/ansible_venv/bin/python3
  when: inventory_hostname in groups['proxmox_servers'] | default([])

# --- OPTIONAL: Nuke and Pave (Force Recreate) ---
# ansible-playbook playbooks/samba.yml -e "force_recreate=true"

- name: Check if VM exists (Pre-destruction check)
  ansible.builtin.command:
    cmd: "qm status {{ create_vm_newid }}"
  register: create_vm_pre_destroy_check
  failed_when: false
  changed_when: false
  # Only bother checking if we actually intend to recreate
  when: force_recreate | default(false) | bool

- name: Stop VM before destruction
  ansible.builtin.command:
    cmd: "qm stop {{ create_vm_newid }}"
  register: create_vm_stop_result
  failed_when: create_vm_stop_result.rc not in [0, 2]
  changed_when: "'stopped' not in create_vm_stop_result.stdout"
  when:
    - force_recreate | default(false) | bool
    - create_vm_pre_destroy_check.rc == 0

- name: Destroy existing VM (Force Recreate)
  ansible.builtin.command:
    cmd: "qm destroy {{ create_vm_newid }} --purge"
  when:
    - force_recreate | default(false) | bool
    - create_vm_pre_destroy_check.rc == 0

# --- STEP 1: Bootstrap VM (Check, Clone & Configure) ---

# 1. First, check if the VM already exists
- name: Check if VM exists
  ansible.builtin.command:
    cmd: "qm status {{ create_vm_newid }}"
  register: create_vm_status_check
  failed_when: false
  changed_when: false

# 2. Only runs if the VM was NOT found (rc != 0)
- name: Clone VM and Apply Network Config (CLI)
  ansible.builtin.shell: |
    # Clone the VM
    qm clone {{ template.vmid }} {{ create_vm_newid }} --name {{ create_vm_name }} --full 1

    # Apply IP config immediately (Fixes the "No route to host" race condition)
    qm set {{ create_vm_newid }} --ipconfig0 "ip={{ create_vm_ipaddr }}/24,gw={{ create_vm_gateway }}"

  when: create_vm_status_check.rc != 0

# --- STEP 3: Hardware Resources (Idempotent CLI) ---

- name: Get current VM configuration (JSON)
  ansible.builtin.command:
    cmd: "/usr/bin/pvesh get /nodes/{{ create_vm_target_node }}/qemu/{{ create_vm_newid }}/config --output-format json"
  register: create_vm_config_json
  changed_when: false
  check_mode: false

- name: Ensure VM Resource Allocation
  ansible.builtin.command:
    cmd: "qm set {{ create_vm_newid }} --cores {{ create_vm_cores }} --sockets {{ create_vm_sockets }} --memory {{ create_vm_memory }} --balloon {{ create_vm_balloon }} --onboot 1"
  vars:
    config: "{{ create_vm_config_json.stdout | from_json }}"
    cur_cores: "{{ config.cores | default(1) | int }}"
    cur_sockets: "{{ config.sockets | default(1) | int }}"
    cur_memory: "{{ config.memory | default(512) | int }}"
    cur_balloon: "{{ config.balloon | default(cur_memory) | int }}"
  when:
    - (cur_cores != create_vm_cores | int) or
      (cur_sockets != create_vm_sockets | int) or
      (cur_memory != create_vm_memory | int) or
      (cur_balloon != create_vm_balloon | int)
  notify: "reboot vm"

- name: Resize Primary Disk
  ansible.builtin.command:
    cmd: "qm resize {{ create_vm_newid }} {{ create_vm_disk_name }} {{ create_vm_disk_size }}"
  vars:
    disk_config: "{{ (create_vm_config_json.stdout | from_json)[create_vm_disk_name] | default('') }}"
    current_size_capture: "{{ disk_config | regex_search('size=([0-9]+[GM])', '\\1') }}"
    current_size: "{{ current_size_capture[0] if current_size_capture else 'unknown' }}"
  when:
    - current_size != 'unknown'
    - current_size != create_vm_disk_size
  notify: "reboot vm"

- name: Set virtiofs0 configuration
  ansible.builtin.command:
    cmd: "qm set '{{ create_vm_newid }}' --virtiofs0 '{{ create_vm_virtiofs_tag }},expose-xattr=1'"
  vars:
    current_virtiofs: "{{ (create_vm_config_json.stdout | from_json).virtiofs0 | default('') }}"
  when:
    - create_vm_virtiofs_tag is defined
    - create_vm_virtiofs_tag | length > 0
    - create_vm_virtiofs_tag not in current_virtiofs
  notify: "reboot vm"

# --- STEP 4: Final Checks ---

- name: Check VM status before starting
  ansible.builtin.command:
    cmd: "qm status {{ create_vm_newid }}"
  register: create_vm_status_final
  changed_when: false

- name: Ensure VM is running (Final Check)
  ansible.builtin.command:
    cmd: "qm start {{ create_vm_newid }}"
  when:
    - create_vm_status_final.rc == 0
    - "'stopped' in create_vm_status_final.stdout"
  changed_when: true

# --- STEP 5: Connectivity Wait (The Fix) ---
- name: Wait for VM to initialize and SSH to become accessible
  ansible.builtin.wait_for:
    host: "{{ create_vm_ipaddr }}"
    port: 22
    state: started
    search_regex: OpenSSH # Ensures SSH is actually ready to accept login
    delay: 10 # Wait 10s before starting to check
    timeout: 600 # Wait up to 10 minutes
  delegate_to: localhost # Run check from the runner
